<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>IC Studios — Physics Dev Sandbox</title>
  <style>
  /* --- Your site chrome (kept exact) --- */
  body {
    margin: 0;
    background: #000;
    color: #fff;
    font-family: 'Segoe UI', Verdana, Arial, sans-serif;
    font-size: 15px;
    line-height: 1.6;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    opacity: 0;
    animation: fadeIn 0.6s ease-out forwards;
    user-select: none;
  }
  @keyframes fadeIn { from { opacity: 0 } to { opacity: 1 } }

  header {
    background: linear-gradient(to bottom, #222, #111);
    box-shadow: 0 2px 6px rgba(0,0,0,0.6);
    padding: 15px 20px;
    display: flex;
    justify-content: center;
  }
  .header-center { display:flex; flex-direction:column; align-items:center }
  .main-logo { max-height:100px; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5)); transition: transform .3s }
  .main-logo:hover { transform: scale(1.03) }
  .motto { max-height:40px; margin-top:8px; opacity:.9 }

  .layout { flex:1; display:flex; min-height:0 }
  nav {
    background: linear-gradient(to bottom, #222, #111);
    width: 200px;
    padding: 25px 20px;
    border-right: 2px solid #333;
    box-shadow: inset -2px 0 6px rgba(0,0,0,0.4);
    display:flex; flex-direction:column;
  }
  .nav-list { list-style:none; margin:0; padding:0; flex-grow:1 }
  .nav-list li { margin-bottom: 12px }
  .nav-list a {
    display:block; padding:10px 14px; background:#333; border:1px solid #444;
    border-radius:6px; font-family:"Courier New", monospace; font-size:14px;
    color:#99ccff; text-decoration:none; box-shadow:0 1px 4px rgba(0,0,0,0.4);
    transition: background .25s, border-color .25s, transform .25s, box-shadow .25s;
  }
  .nav-list a:hover {
    background:#444; border-color:#66aaff; color:#66aaff; transform: translateY(-2px);
    box-shadow:0 4px 10px rgba(0,0,0,0.5);
  }

  /* --- Main area uses a dev-style minimal UI --- */
  main {
    flex:1; background:#000; padding:30px; overflow-y:auto;
    display:flex; flex-direction:column; align-items:center;
  }

  /* --- Physics sandbox layout & developer styling --- */
  #app {
    width:100%; max-width: 1040px; display:flex; flex-direction:column; align-items:center;
  }

  #toolbar {
    width:100%; display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    background: rgba(30,30,30,0.6); padding:10px; border-radius:6px;
    border: 1px solid #222; box-shadow: inset 0 -1px 0 #111;
    margin-bottom:12px;
  }
  .btn {
    background:#111; border:1px solid #333; padding:8px 12px; border-radius:6px;
    color:#99ccff; font-family:"Courier New", monospace; cursor:pointer;
    transition: all .18s; font-size:13px;
  }
  .btn:hover { transform: translateY(-2px); border-color:#66aaff; color:#66aaff; }
  .btn.toggle-on { background:#062; color:#bfffbf; border-color:#0a6; }
  .btn.critical { background:#220; color:#ffbebe; border-color:#aa6666; }
  .label { color:#88ccee; font-family:"Courier New", monospace; font-size:13px; margin-right:6px }

  #panel {
    display:flex; width:100%; gap:12px;
  }

  #canvas-column {
    flex:1;
    display:flex; flex-direction:column; align-items:center;
  }

  /* container that rotates during 2D<->3D transition */
  .viewport-wrap {
    width:100%; max-width:960px; height:640px; perspective:1400px;
    display:flex; align-items:center; justify-content:center;
  }

  .viewport {
    width:100%; height:100%; position:relative; transform-style: preserve-3d;
    transition: transform 900ms cubic-bezier(.2,.9,.2,1), box-shadow 300ms;
  }

  /* two canvases stacked: one 2D, one WebGL 3D */
  canvas {
    display:block; width:100%; height:100%; border-radius:6px; background:#111;
    position:absolute; left:0; top:0;
  }
  #canvas2d { z-index:5 }
  #canvas3d { z-index:4; opacity:0; }

  /* hud overlays */
  #debug {
    position:absolute; left:12px; top:12px; font-family:monospace; font-size:13px;
    color:#66aaffcc; background:rgba(0,0,0,0.35); padding:6px 8px; border-radius:6px; pointer-events:none;
  }
  #tooltip {
    position:absolute; pointer-events:none; font-family:monospace; font-size:13px;
    color:#66aaff; background:#111; border:1px solid #223344; padding:6px 8px; border-radius:4px; opacity:0;
  }

  /* inspector panel */
  #inspector {
    width:300px; background:rgba(20,20,20,0.6); border-radius:6px; padding:12px; color:#99ccff;
    border:1px solid #222; font-family: "Courier New", monospace; font-size:13px;
  }
  #inspector h3 { margin:0 0 8px 0; color:#66aaff }
  .prop { display:flex; justify-content:space-between; margin-bottom:8px }
  .small { font-size:12px; color:#88aaff }

  /* slider style */
  input[type="range"] { -webkit-appearance:none; width:140px; height:6px; background:#222; border-radius:4px; }
  input[type="range"]::-webkit-slider-thumb { -webkit-appearance:none; width:14px; height:14px; border-radius:50%; background:#66aaff; border:1px solid #3388ff; box-shadow:0 0 6px #66aaff88; margin-top:-4px; cursor:pointer; }

  /* instructions footer */
  #kbd {
    margin-top:10px; color:#88bbff; font-family: "Courier New", monospace; font-size:13px;
    background: rgba(0,0,0,0.4); padding:8px 10px; border-radius:6px;
  }
  </style>
</head>
<body>
  <header>
    <div class="header-center"><img src="images/ICStudios.png" alt="IC Studios Logo" class="main-logo"> <img src="images/ICStudiosMotto.png" alt="Motto" class="motto"></div>
  </header>
  <div class="layout">
    <nav>
      <ul class="nav-list">
        <li>
          <a href="index.html">Home</a>
        </li>
        <li>
          <a href="games.html">Games</a>
        </li>
        <li>
          <a href="OS.html">Operating System</a>
        </li>
        <li>
          <a href="screenshots.html">Screenshots</a>
        </li>
        <li>
          <a href="downloads.html">Downloads</a>
        </li>
        <li>
          <a href="about.html">About</a>
        </li>
        <li>
          <a href="soundtracks.html">Soundtracks</a>
        </li>
        <li>
          <a href="contact.html">Contact</a>
        </li>
        <li>
          <a href="discord.html">Discord</a>
        </li>
      </ul>
    </nav>
    <main>
      <div id="app">
        <div id="toolbar" role="toolbar" aria-label="Physics controls">
          <span class="label">Mode</span> <button id="mode2d" class="btn">2D</button> <button id="mode3d" class="btn">3D</button> <span class="label">Spawn</span> <button id="spawnCircle" class="btn">Circle</button> <button id="spawnBox" class="btn">Box</button> <button id="spawnPoly" class="btn">Poly</button> <button id="spawnCompound" class="btn">Compound</button> <span class="label">Physics</span> <button id="toggleSprings" class="btn">Springs</button> <button id="pauseBtn" class="btn">Pause</button> <button id="slowBtn" class="btn">Slow</button> <span class="label">Gravity</span> <input id="gravRange" type="range" min="0" max="3" step="0.05" value="1"> <button id="saveBtn" class="btn">Save</button> <button id="loadBtn" class="btn">Load</button> <button id="resetBtn" class="btn critical">Reset</button>
        </div>
        <div id="panel">
          <div id="canvas-column">
            <div class="viewport-wrap">
              <div id="viewport" class="viewport">
                <canvas id="canvas3d" width="960" height="640"></canvas>
                <canvas id="canvas2d" width="960" height="640"></canvas>
                <div id="debug" aria-live="polite">
                  FPS: -- | Bodies: 0
                </div>
                <div id="tooltip" role="tooltip"></div>
              </div>
            </div>
            <div id="kbd" aria-hidden="false">
              Keys: C(circle) B(box) P(poly) M(compound) S(springs) G(toggle gravity) Space(pause) | Drag bodies with mouse | Right-click to spawn at mouse
            </div>
          </div>
          <aside id="inspector" aria-label="Inspector">
            <h3>Inspector</h3>
            <div class="prop">
              <div>
                Selected:
              </div>
              <div id="selId">
                None
              </div>
            </div>
            <div class="prop">
              <div>
                Type:
              </div>
              <div id="selType">
                —
              </div>
            </div>
            <div class="prop">
              <div>
                Pos:
              </div>
              <div id="selPos">
                —
              </div>
            </div>
            <div class="prop">
              <div>
                Vel:
              </div>
              <div id="selVel">
                —
              </div>
            </div>
            <div class="prop">
              <div>
                Mass:
              </div>
              <div id="selMass">
                —
              </div>
            </div>
            <div class="prop small">
              <div>
                Save / Load
              </div>
            </div>
            <div class="prop">
              <input id="sceneName" placeholder="name.json" style="flex:1;background:#000;border:1px solid #222;color:#99ccff;padding:6px;border-radius:4px">
            </div>
            <div style="display:flex; gap:8px; margin-top:8px">
              <button id="downloadBtn" class="btn">Download JSON</button> <button id="pasteLoadBtn" class="btn">Paste JSON to Load</button>
            </div>
          </aside>
        </div>
      </div>
    </main>
  </div>
  <script>
  /* =============================================================================
   Full native 2D + 3D shared physics sandbox
   - Physics runs in 3D vectors for all bodies.
   - 2D renderer projects x/y (ignores z). 3D renderer uses WebGL.
   - Smooth CSS rotation transition between 2D and 3D views.
   - No external libraries.
   ============================================================================= */

  /* ---------------------------
   Basic vector utilities (Vec3)
   --------------------------- */
  function v3(x=0,y=0,z=0){ return {x:+x,y:+y,z:+z} }
  function v3add(a,b){ return {x:a.x+b.x,y:a.y+b.y,z:a.z+b.z} }
  function v3sub(a,b){ return {x:a.x-b.x,y:a.y-b.y,z:a.z-b.z} }
  function v3scale(a,s){ return {x:a.x*s,y:a.y*s,z:a.z*s} }
  function v3len(a){ return Math.sqrt(a.x*a.x + a.y*a.y + a.z*a.z) }
  function v3norm(a){ let L=v3len(a); if(L===0) return {x:0,y:0,z:0}; return v3scale(a,1/L) }
  function v3dot(a,b){ return a.x*b.x + a.y*b.y + a.z*b.z }

  /* -------------------
   Global engine state
   ------------------- */
  const state = {
  bodies: [],         // all bodies (shared 3D physics)
  constraints: [],    // springs
  nextId: 1,
  gravity: 1.0,
  paused: false,
  slow: false,
  mode3D: false,
  springsOn: false,
  maxBodies: 400,
  };

  /* ---------------
   Body template
   ---------------
   type: 'sphere'|'box'|'poly'|'compound'
   pos: {x,y,z}
   vel: {x,y,z}
   ang: rotation info (minimal)
   size: radius for spheres, {x,y,z} for boxes
   mass, invMass
   restitution, friction
   color
  */
  function makeBody(opts){
  const b = {
    id: state.nextId++,
    type: opts.type || 'sphere',
    pos: v3(opts.x||0, opts.y||0, opts.z||0),
    vel: v3(opts.vx||0, opts.vy||0, opts.vz||0),
    ang: {x:0,y:0,z:0},
    size: opts.size || 20,
    mass: opts.mass || 1,
    invMass: opts.mass ? 1/opts.mass : 1,
    restitution: (opts.restitution==null ? 0.6 : opts.restitution),
    friction: (opts.friction==null ? 0.15 : opts.friction),
    color: opts.color || randomColor(),
    lifetime: 0,
    user: opts.user || {},
  };
  // radius helper for broadphase (sphere approx)
  b.radius = (b.type === 'box') ? Math.max(b.size.x,b.size.y,b.size.z)/2 : b.size;
  return b;
  }

  /* -----------------
   Random helpers
   ----------------- */
  function randomColor(){
  const hues = [190,200,210,220,230,250,280];
  const h = hues[Math.floor(Math.random()*hues.length)];
  const s = 60 + Math.floor(Math.random()*20);
  const l = 45 + Math.floor(Math.random()*15);
  return `hsl(${h},${s}%,${l}%)`;
  }
  function rand(min,max){ return min + Math.random()*(max-min) }

  /* -----------------------
   Physics integrator (simple)
   -----------------------
   Very light: semi-implicit Euler with simple collision resolution
  */
  const PHYS = {
  dt: 1/60,
  substeps: 1,
  stepsSinceCleanup:0,
  integrate(dt){
    const accGravity = {x:0, y:PHYS.gravity * -1, z:0}; // y-up negative (canvas Y increases down)
    // substeps for stability if needed
    for(let s=0;s<PHYS.substeps;s++){
      for(const b of state.bodies){
        if(b.invMass === 0) continue; // static
        // integrate velocity
        b.vel.x += accGravity.x * dt;
        b.vel.y += accGravity.y * dt;
        b.vel.z += accGravity.z * dt;

        // damping (air/friction)
        b.vel.x *= (1 - Math.min(b.friction || 0.01, 0.12));
        b.vel.y *= (1 - Math.min(b.friction || 0.01, 0.12));
        b.vel.z *= (1 - Math.min(b.friction || 0.01, 0.12));

        // integrate position
        b.pos.x += b.vel.x * dt;
        b.pos.y += b.vel.y * dt;
        b.pos.z += b.vel.z * dt;
        b.lifetime += dt;
      }

      // simple broadphase: naive O(n^2) check (we limit maxBodies)
      const n = state.bodies.length;
      for(let i=0;i<n;i++){
        const A = state.bodies[i];
        for(let j=i+1;j<n;j++){
          const B = state.bodies[j];
          handleCollisionPair(A,B);
        }
      }

      // ground plane at y = canvasHeight/2 in our world coords; we'll map later
      for(const b of state.bodies){
        // ground plane at y = -300 (converted to our coordinate system)
        const groundY = -300;
        if(b.pos.y - b.radius < groundY){
          // push up
          b.pos.y = groundY + b.radius;
          if(b.vel.y < 0) b.vel.y *= -b.restitution;
          // friction with ground
          b.vel.x *= (1 - (b.friction*0.5));
          b.vel.z *= (1 - (b.friction*0.5));
          // small energy loss
          b.vel.x *= 0.98; b.vel.z *= 0.98;
        }
      }

      // apply constraint springs
      for(const c of state.constraints){
        applySpring(c, dt);
      }
    }
  }
  };

  PHYS.gravity = 1.0;

  /* -----------------------
   Collision (sphere-sphere approximation)
   ----------------------- */
  function handleCollisionPair(A,B){
  // skip if both static
  if(A.invMass === 0 && B.invMass === 0) return;
  // distance
  const diff = v3sub(B.pos, A.pos);
  const dist = v3len(diff);
  const minDist = (A.radius + B.radius);
  if(dist <= 0) return;
  if(dist < minDist - 0.0001){
    // penetration resolution
    const normal = v3scale(diff, 1/dist);
    const penetration = minDist - dist;
    const totalInv = (A.invMass + B.invMass) || 1;
    // move along normal
    const moveA = v3scale(normal, -penetration * (A.invMass / totalInv));
    const moveB = v3scale(normal, penetration * (B.invMass / totalInv));
    if(A.invMass > 0){
      A.pos = v3add(A.pos, moveA);
    }
    if(B.invMass > 0){
      B.pos = v3add(B.pos, moveB);
    }
    // relative velocity
    const rv = v3sub(B.vel, A.vel);
    const contactVel = v3dot(rv, normal);
    // only if closing
    if(contactVel < 0){
      const restitution = Math.min(A.restitution, B.restitution);
      const j = -(1 + restitution) * contactVel / totalInv;
      const impulse = v3scale(normal, j);
      if(A.invMass > 0) A.vel = v3sub(A.vel, v3scale(impulse, A.invMass));
      if(B.invMass > 0) B.vel = v3add(B.vel, v3scale(impulse, B.invMass));
      // friction: tangential velocity dampening
      const tangent = v3sub(rv, v3scale(normal, contactVel));
      const tlen = v3len(tangent);
      if(tlen > 0.0001){
        const tdir = v3scale(tangent, 1/tlen);
        const mu = Math.sqrt(A.friction * B.friction);
        const jt = -v3dot(rv, tdir) / totalInv;
        const maxFriction = j * mu;
        const jtClamped = Math.max(-maxFriction, Math.min(maxFriction, jt));
        const frImp = v3scale(tdir, jtClamped);
        if(A.invMass > 0) A.vel = v3sub(A.vel, v3scale(frImp, A.invMass));
        if(B.invMass > 0) B.vel = v3add(B.vel, v3scale(frImp, B.invMass));
      }
    }
  }
  }

  /* -----------------------
   Springs (soft constraints)
   ----------------------- */
  function addSpring(aId, bId, length, k=0.05, damp=0.02){
  const a = state.bodies.find(x=>x.id===aId);
  const b = state.bodies.find(x=>x.id===bId);
  if(!a || !b) return null;
  const c = {aId, bId, length, k, damp};
  state.constraints.push(c);
  return c;
  }
  function applySpring(c, dt){
  const A = state.bodies.find(x=>x.id===c.aId);
  const B = state.bodies.find(x=>x.id===c.bId);
  if(!A || !B) return;
  const diff = v3sub(B.pos, A.pos);
  const dist = v3len(diff) || 0.0001;
  const dir = v3scale(diff, 1/dist);
  const x = dist - c.length;
  const force = c.k * x;
  // relative velocity along dir
  const rv = v3dot(v3sub(B.vel, A.vel), dir);
  const dampF = c.damp * rv;
  const total = force + dampF;
  if(A.invMass>0) A.vel = v3add(A.vel, v3scale(dir, total * A.invMass * -1 * PHYS.dt));
  if(B.invMass>0) B.vel = v3add(B.vel, v3scale(dir, total * B.invMass * PHYS.dt));
  }

  /* -----------------------
   Scene operations (spawn/save/load)
   ----------------------- */
  function spawnCircle(x,y,z){
  const b = makeBody({type:'sphere', x, y, z, size: rand(10,28), mass: rand(0.6,3), restitution: 0.7, friction: 0.12});
  state.bodies.push(b);
  trimBodies();
  return b;
  }
  function spawnBox(x,y,z){
  const size = {x: rand(20,60), y: rand(20,60), z: rand(20,60)};
  const b = makeBody({type:'box', x,y,z, size, mass: rand(1,6), restitution:0.5, friction:0.18});
  state.bodies.push(b);
  trimBodies();
  return b;
  }
  function spawnPoly(x,y,z){
  // represent poly as sphere-approx with polygon user data
  const b = makeBody({type:'poly', x,y,z, size: rand(18,45), mass: rand(0.8,4), restitution:0.6, friction:0.15});
  b.polySides = Math.floor(rand(5,9));
  state.bodies.push(b);
  trimBodies();
  return b;
  }
  function spawnCompound(x,y,z){
  const b = makeBody({type:'compound', x,y,z, size: rand(28,48), mass: rand(2,8), restitution:0.55, friction:0.2});
  b.compParts = [
    {off:v3(-b.size*0.3,0,0), size: b.size*0.6},
    {off:v3(b.size*0.4,0,0), size: b.size*0.45}
  ];
  state.bodies.push(b);
  trimBodies();
  return b;
  }

  function trimBodies(){
  if(state.bodies.length > state.maxBodies){
    // remove oldest
    state.bodies.sort((a,b)=>a.lifetime - b.lifetime);
    while(state.bodies.length > state.maxBodies){
      const rem = state.bodies.shift();
    }
  }
  }

  /* -----------------------
   Persistence (save/load)
   ----------------------- */
  function exportScene(){
  const s = {
    gravity: state.gravity,
    bodies: state.bodies.map(b => ({
      id: b.id, type:b.type, pos:b.pos, vel:b.vel, size:b.size, mass:b.mass, color:b.color, restitution:b.restitution, friction:b.friction, user:b.user
    }))
  };
  return JSON.stringify(s, null, 2);
  }
  function importScene(json){
  try{
    const s = (typeof json === 'string') ? JSON.parse(json) : json;
    // clear existing
    state.bodies.length = 0; state.constraints.length = 0;
    PHYS.gravity = s.gravity != null ? s.gravity : PHYS.gravity;
    for(const bi of s.bodies || []){
      const nb = makeBody({
        type: bi.type, x: bi.pos.x, y: bi.pos.y, z: bi.pos.z,
        vx: bi.vel.x, vy: bi.vel.y, vz: bi.vel.z,
        size: bi.size, mass: bi.mass, restitution: bi.restitution, friction: bi.friction, color: bi.color, user:bi.user
      });
      state.bodies.push(nb);
    }
    trimBodies();
  }catch(e){ alert('Invalid JSON'); }
  }

  /* -----------------------
   Rendering 2D (canvas)
   ----------------------- */
  const c2d = document.getElementById('canvas2d');
  const ctx = c2d.getContext('2d');

  function resizeCanvases(){
  const vw = Math.min(window.innerWidth * 0.9, 960);
  const vh = 640;
  c2d.style.width = vw + 'px'; c2d.style.height = vh + 'px';
  canvas3d.style.width = vw + 'px'; canvas3d.style.height = vh + 'px';
  c2d.width = Math.round(vw * devicePixelRatio);
  c2d.height = Math.round(vh * devicePixelRatio);
  canvas3d.width = Math.round(vw * devicePixelRatio);
  canvas3d.height = Math.round(vh * devicePixelRatio);
  // update camera scale
  view.width = c2d.width; view.height = c2d.height;
  }
  window.addEventListener('resize', resizeCanvases);

  /* --------------
   DEV view parameters
   -------------- */
  const view = { width: c2d.width||960, height: c2d.height||640, scale:1, offsetX:0, offsetY:0 };

  /* Project world (3D) to 2D canvas for 2D mode:
   We'll simply map x,z to canvas x, y to canvas y (y up)
   world coords: x right, y up, z forward
   canvas coords: x right, y down -> screenY = centerY - worldY
  */
  function worldToScreen(p){
  // choose a scaling factor: 1 world unit = 1 px roughly; apply a global scale
  const hw = view.width / 2;
  const hh = view.height / 2;
  const sx = hw + (p.x + view.offsetX) * view.scale;
  const sy = hh - (p.y + view.offsetY) * view.scale;
  return {x:sx, y:sy};
  }

  function render2D(){
  const W = c2d.width, H = c2d.height;
  ctx.save();
  ctx.clearRect(0,0,W,H);
  // background grid (dev style)
  ctx.fillStyle = '#0b0b0b'; ctx.fillRect(0,0,W,H);
  drawGrid(ctx, W, H);

  // draw bodies
  for(const b of state.bodies){
    const p = worldToScreen(b.pos);
    ctx.save();
    // outline style, Baszucki dev look
    ctx.lineWidth = 2 * devicePixelRatio;
    ctx.strokeStyle = '#223344';
    ctx.fillStyle = b.color;
    if(b.type === 'sphere'){
      const r = Math.max(2, b.size * view.scale * devicePixelRatio);
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
    } else if(b.type === 'box'){
      const hw = (b.size.x/2) * view.scale * devicePixelRatio;
      const hh = (b.size.y/2) * view.scale * devicePixelRatio;
      ctx.beginPath();
      ctx.rect(p.x - hw, p.y - hh, hw*2, hh*2);
      ctx.fill();
      ctx.stroke();
    } else if(b.type === 'poly'){
      // draw as polygon approximated in 2D
      const sides = b.polySides || 6;
      const r = Math.max(4, b.size * view.scale * devicePixelRatio);
      ctx.beginPath();
      for(let i=0;i<sides;i++){
        const ang = (i/sides) * Math.PI*2;
        const x = p.x + Math.cos(ang)*r;
        const y = p.y + Math.sin(ang)*r;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath(); ctx.fill(); ctx.stroke();
    } else if(b.type === 'compound'){
      // draw simple two-box compound
      const s = b.size * view.scale * devicePixelRatio;
      const p1x = p.x - s*0.25, p2x = p.x + s*0.25;
      ctx.fillRect(p1x - s*0.3, p.y - s*0.2, s*0.6, s*0.4);
      ctx.fillRect(p2x - s*0.2, p.y - s*0.35, s*0.4, s*0.7);
      ctx.strokeRect(p1x - s*0.3, p.y - s*0.2, s*0.6, s*0.4);
      ctx.strokeRect(p2x - s*0.2, p.y - s*0.35, s*0.4, s*0.7);
    }
    ctx.restore();
  }

  // draw springs
  ctx.strokeStyle = 'rgba(100,160,255,0.5)';
  ctx.lineWidth = 1.5 * devicePixelRatio;
  for(const s of state.constraints){
    const A = state.bodies.find(x=>x.id===s.aId);
    const B = state.bodies.find(x=>x.id===s.bId);
    if(!A || !B) continue;
    const pa = worldToScreen(A.pos), pb = worldToScreen(B.pos);
    ctx.beginPath(); ctx.moveTo(pa.x, pa.y); ctx.lineTo(pb.x, pb.y); ctx.stroke();
  }

  ctx.restore();
  }

  function drawGrid(ctx, W, H){
  ctx.save();
  ctx.strokeStyle = '#081018';
  ctx.lineWidth = 1 * devicePixelRatio;
  const step = 32 * devicePixelRatio;
  for(let x=0; x<W; x+=step){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
  }
  for(let y=0; y<H; y+=step){
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }
  ctx.restore();
  }

  /* Very small shader for colored lambert-ish shading */
  const VSH = `
  attribute vec3 aPosition;
  attribute vec3 aNormal;

  uniform mat4 uMVP;
  uniform mat4 uModel;
  uniform mat3 uNormal;

  varying vec3 vNormal;
  varying vec3 vPos;

  void main(){
  vNormal = normalize(uNormal * aNormal);
  vec4 worldPos = uModel * vec4(aPosition, 1.0);
  vPos = worldPos.xyz;
  gl_Position = uMVP * vec4(aPosition, 1.0);
  }
  `;

  const FSH = `
  precision mediump float;

  varying vec3 vNormal;
  varying vec3 vPos;

  uniform vec3 uLightDir;
  uniform vec3 uColor;

  void main(){
  vec3 normal = normalize(vNormal);
  float diff = max(dot(normal, normalize(uLightDir)), 0.0);
  vec3 diffuse = uColor * diff;
  vec3 ambient = uColor * 0.2;
  gl_FragColor = vec4(diffuse + ambient, 1.0);
  }
  `;

  // Create and link program
  const program = createProgram(VSH, FSH);
  gl.useProgram(program);

  // Lookup attribute/uniform locations
  const aPositionLoc = gl.getAttribLocation(program, "aPosition");
  const aNormalLoc = gl.getAttribLocation(program, "aNormal");
  const uMVPLoc = gl.getUniformLocation(program, "uMVP");
  const uModelLoc = gl.getUniformLocation(program, "uModel");
  const uNormalLoc = gl.getUniformLocation(program, "uNormal");
  const uLightDirLoc = gl.getUniformLocation(program, "uLightDir");
  const uColorLoc = gl.getUniformLocation(program, "uColor");

  // Setup buffers (example for a cube)
  const cubePositions = new Float32Array([
  // ... vertex positions ...
  ]);

  const cubeNormals = new Float32Array([
  // ... vertex normals ...
  ]);

  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, cubePositions, gl.STATIC_DRAW);

  const normalBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, cubeNormals, gl.STATIC_DRAW);

  // Enable attributes
  gl.enableVertexAttribArray(aPositionLoc);
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.vertexAttribPointer(aPositionLoc, 3, gl.FLOAT, false, 0, 0);

  gl.enableVertexAttribArray(aNormalLoc);
  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
  gl.vertexAttribPointer(aNormalLoc, 3, gl.FLOAT, false, 0, 0);

  // Prepare matrices (you’ll want to implement matrix math or use a small lib)
  const modelMatrix = mat4.create(); // identity
  const viewMatrix = mat4.create();
  const projMatrix = mat4.create();
  const mvpMatrix = mat4.create();
  const normalMatrix = mat3.create();

  // Set light direction and base color
  gl.uniform3fv(uLightDirLoc, [0.5, 0.7, 1.0]);
  gl.uniform3fv(uColorLoc, [0.4, 0.6, 0.9]);

  // In your render loop:
  // - update modelMatrix, viewMatrix, projMatrix based on camera & object
  // - compute normalMatrix as inverse transpose of modelMatrix
  // - compute mvpMatrix = proj * view * model
  // - upload all uniforms
  // - draw arrays or elements

  // Example (assuming you have a render loop):
  function render() {
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // Update matrices here...

  gl.uniformMatrix4fv(uMVPLoc, false, mvpMatrix);
  gl.uniformMatrix4fv(uModelLoc, false, modelMatrix);
  gl.uniformMatrix3fv(uNormalLoc, false, normalMatrix);

  // Draw call here...

  requestAnimationFrame(render);
  }

  gl.enable(gl.DEPTH_TEST);
  gl.clearColor(0.1, 0.1, 0.1, 1);
  render();


  </script>
</body>
</html>